<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Rule 3.2 -->
    <title>PSP Оборудование: Поиск по Интернет-Источникам</title> 
    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Настройки шрифта и основного контейнера */
        :root {
            --dark-bg: #030712; /* Базовый темный фон */
            --card-bg: #111827; /* Фон карточек, как в правилах (Rule 4.3) */
            --accent-color: #4f46e5; /* Индиго для акцентов */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            color: #f3f4f6;
        }

        /* Стиль для карточки результата с анимацией (Rule 4.3) */
        .equipment-card {
            background-color: var(--card-bg);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        /* Анимация при наведении (Rule 4.3) */
        .equipment-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -4px rgba(0, 0, 0, 0.3);
        }

        /* Кастомный стиль для бейджа Лучшего Предложения (Rule 4.4) */
        .rank-badge {
            animation: pulse-rank 2s infinite;
        }

        @keyframes pulse-rank {
            0%, 100% { background-color: #f59e0b; box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); }
            50% { background-color: #d97706; box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8">

    <div class="max-w-7xl mx-auto">
        
        <!-- Заголовок -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-white mb-2">Агрегатор PSP Оборудования</h1>
            <p class="text-lg text-gray-400">Поиск предложений из различных интернет-источников</p>
        </header>

        <!-- Форма Поиска -->
        <form id="searchForm" class="mb-8 p-4 bg-gray-800 rounded-xl shadow-2xl">
            <div class="flex flex-col sm:flex-row gap-4">
                <input type="text" id="searchInput" placeholder="Введите название оборудования (напр., Shure SM58)" 
                       class="flex-grow p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-indigo-500 focus:border-indigo-500" 
                       required>
                <button type="submit" id="searchButton" 
                        class="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    Начать Поиск
                </button>
            </div>
            <p id="statusMessage" class="mt-3 text-center text-gray-500 text-sm"></p>
        </form>

        <!-- Блок Фильтров -->
        <div id="filterBlock" class="mb-8 p-4 bg-gray-800 rounded-xl shadow-2xl border-t-2 border-indigo-600 hidden">
            <h2 class="text-xl font-semibold mb-3">Фильтр по цене (₽)</h2>
            <div class="flex flex-col sm:flex-row gap-4 items-center">
                <input type="number" id="priceFilterMin" placeholder="Мин. цена" 
                       class="w-full sm:w-auto p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-indigo-500 focus:border-indigo-500" min="0">
                <span class="text-gray-400 hidden sm:inline">-</span>
                <input type="number" id="priceFilterMax" placeholder="Макс. цена" 
                       class="w-full sm:w-auto p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-indigo-500 focus:border-indigo-500" min="0">
                <button type="button" id="applyFiltersButton"
                        class="w-full sm:w-auto px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg shadow-md transition duration-200">
                    Применить Фильтр
                </button>
            </div>
        </div>

        <!-- Контейнер Результатов -->
        <div id="resultsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
            <!-- Здесь будут отображаться карточки результатов -->
        </div>

        <!-- Блок Пагинации -->
        <div id="paginationBlock" class="flex justify-between items-center p-4 bg-gray-800 rounded-xl shadow-2xl border-t-2 border-indigo-600 hidden">
            <button id="prevPageButton" 
                    class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                ← Предыдущая
            </button>
            <span id="pageInfo" class="text-white font-medium">Страница 1 из 1</span>
            <button id="nextPageButton" 
                    class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                Следующая →
            </button>
        </div>

        <!-- Блок Логирования (для отладки) -->
        <div class="mt-8">
            <h2 class="text-xl font-semibold text-gray-300 mb-2">Лог Фронтенда (Отладка)</h2>
            <div id="logArea" class="bg-gray-900 p-4 rounded-lg text-sm text-gray-400 h-40 overflow-y-auto">
                <!-- Сообщения лога будут здесь -->
            </div>
        </div>

    </div>

    <script>
        // Константы и глобальные переменные
        const API_URL = 'https://PSP-Search-API.example.com/api/search'; // Имитация URL API
        const ITEMS_PER_PAGE = 5; // Rule 2.4.d
        
        let allResults = [];      // Все полученные результаты от API (Rule 2.4.a)
        let filteredResults = []; // Результаты после фильтрации
        let currentPage = 1;

        // Элементы DOM
        const searchForm = document.getElementById('searchForm');
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const statusMessage = document.getElementById('statusMessage');
        const resultsContainer = document.getElementById('resultsContainer');
        const logArea = document.getElementById('logArea');
        const filterBlock = document.getElementById('filterBlock');
        const priceFilterMin = document.getElementById('priceFilterMin');
        const priceFilterMax = document.getElementById('priceFilterMax');
        const applyFiltersButton = document.getElementById('applyFiltersButton');
        const paginationBlock = document.getElementById('paginationBlock');
        const prevPageButton = document.getElementById('prevPageButton');
        const nextPageButton = document.getElementById('nextPageButton');
        const pageInfo = document.getElementById('pageInfo');

        // --- Вспомогательные Функции ---

        /** Добавляет сообщение в лог отладки (Rule 2.1.b) */
        function appendToLog(message) {
            const time = new Date().toLocaleTimeString('ru-RU');
            logArea.innerHTML += `<div>[${time}] ${message}</div>`;
            logArea.scrollTop = logArea.scrollHeight; // Прокрутка вниз
        }

        /** Очищает состояние приложения (Rule 2.1.b) */
        function resetState() {
            allResults = [];
            filteredResults = [];
            currentPage = 1;
            resultsContainer.innerHTML = '';
            logArea.innerHTML = '';
            filterBlock.classList.add('hidden');
            paginationBlock.classList.add('hidden');
            priceFilterMin.value = '';
            priceFilterMax.value = '';
            appendToLog('[INFO] Состояние сброшено.');
        }

        /** Переводит русский запрос на английский (Rule 2.1.c) */
        async function translateQuery(query) {
            // В реальном приложении здесь был бы вызов API перевода (например, Google Translate)
            // Здесь мы используем простую заглушку для имитации
            const translationMap = {
                'shure sm58': 'Shure SM58 microphone',
                'pioneer cdj 3000': 'Pioneer CDJ-3000',
                'yamaha hs8': 'Yamaha HS8 monitor speaker',
                'микрофон': 'microphone',
                'наушники': 'headphones',
            };
            const lowerQuery = query.toLowerCase();
            const translation = translationMap[lowerQuery] || lowerQuery + ' equipment';

            appendToLog(`[DEBUG] Перевод запроса '${query}' -> '${translation}'`);
            return translation;
        }

        /** Создает карточку результата (Rule 4.3, 4.4) */
        function createResultCard(item) {
            const isBestOffer = item.rank === 1; // Rule 4.4

            // Иконка "Лучшее Предложение"
            const rankBadge = isBestOffer ? `
                <span class="rank-badge absolute top-3 right-3 text-xs font-bold text-white px-3 py-1 rounded-full shadow-lg">
                    Лучшее Предложение
                </span>
            ` : '';
            
            // Форматирование цены в рубли (Rule 1.3)
            const formattedPrice = new Intl.NumberFormat('ru-RU', { 
                style: 'currency', 
                currency: 'RUB',
                minimumFractionDigits: 0
            }).format(item.price);


            const card = document.createElement('div');
            // Rule 4.3: equipment-card, темно-серый фон #111827, белый текст. Анимация при наведении.
            card.className = 'equipment-card relative p-5 rounded-xl text-white flex flex-col justify-between h-full hover:shadow-indigo-500/50';
            card.innerHTML = `
                ${rankBadge}
                <a href="${item.uri}" target="_blank" class="block">
                    <h3 class="text-xl font-bold mb-2 pr-12 text-indigo-400 hover:text-indigo-300 transition-colors">${item.title}</h3>
                </a>
                <p class="text-2xl font-extrabold text-yellow-400 mb-3">${formattedPrice}</p>
                <p class="text-sm text-gray-300 mb-4 flex-grow">${item.snippet}</p>
                <div class="text-xs text-gray-500 mt-auto">
                    Источник: <span class="font-semibold text-gray-400">${item.source}</span>
                    <br>
                    URI: <a href="${item.uri}" target="_blank" class="truncate block text-blue-400 hover:text-blue-300">${item.uri}</a>
                </div>
            `;
            return card;
        }

        /** Отображает результаты текущей страницы */
        function renderPage() {
            resultsContainer.innerHTML = '';
            
            const totalItems = filteredResults.length;
            const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
            const endIndex = Math.min(startIndex + ITEMS_PER_PAGE, totalItems);
            
            // Rule 2.4.d: Пагинация
            const itemsOnPage = filteredResults.slice(startIndex, endIndex);

            if (itemsOnPage.length === 0 && totalItems > 0 && currentPage > 1) {
                // Если на текущей странице нет элементов (например, после фильтрации), 
                // переходим на предыдущую.
                currentPage--;
                renderPage();
                return;
            }

            itemsOnPage.forEach(item => {
                resultsContainer.appendChild(createResultCard(item));
            });
            
            // Обновление пагинации
            const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
            pageInfo.textContent = `Страница ${currentPage} из ${totalPages === 0 ? 1 : totalPages}`;
            prevPageButton.disabled = currentPage === 1 || totalPages === 0;
            nextPageButton.disabled = currentPage === totalPages || totalPages === 0;

            if (totalItems > ITEMS_PER_PAGE) {
                paginationBlock.classList.remove('hidden');
            } else {
                 paginationBlock.classList.add('hidden');
            }
            
            filterBlock.classList.remove('hidden');
            
            appendToLog(`[INFO] Отображена страница ${currentPage} (${itemsOnPage.length} элементов).`);
        }

        /** Применяет фильтры по цене и запускает сортировку/отображение (Rule 2.4.c) */
        function applyFiltersAndSort() {
            const minPrice = parseFloat(priceFilterMin.value) || 0;
            const maxPrice = parseFloat(priceFilterMax.value) || Infinity;
            
            appendToLog(`[INFO] Применение фильтров: Мин=${minPrice || 'Нет'}, Макс=${maxPrice === Infinity ? 'Нет' : maxPrice}`);

            filteredResults = allResults.filter(item => {
                return item.price >= minPrice && item.price <= maxPrice;
            });
            
            // Сортировка по возрастанию цены (Rule 2.4.b) уже выполнена на бэкенде,
            // но мы сохраняем ее для полной уверенности и после фильтрации.
            filteredResults.sort((a, b) => a.price - b.price);

            // Сброс на первую страницу после фильтрации
            currentPage = 1;
            renderPage();
            
            if (filteredResults.length === 0) {
                 statusMessage.textContent = 'Нет результатов, соответствующих заданным критериям фильтрации.';
                 statusMessage.classList.remove('text-green-500', 'text-gray-500');
                 statusMessage.classList.add('text-red-500');
            } else {
                 statusMessage.textContent = `Найдено ${filteredResults.length} результатов. Отсортировано по цене.`;
                 statusMessage.classList.remove('text-red-500');
                 statusMessage.classList.add('text-green-500');
            }
        }

        // --- Основная Логика Поиска (Rule 2.2) ---

        /** * Выполняет запрос к API для получения результатов поиска. 
         * @param {string[]} queries - Массив запросов (Rule 2.2.a) 
         */
        async function fetchSearchResults(query) {
            resetState(); // Очищаем предыдущие результаты (Rule 2.1.b)
            
            const query_ru = query;
            const query_en = await translateQuery(query); // Rule 2.1.c

            searchButton.disabled = true;
            statusMessage.textContent = 'Выполняется поиск, пожалуйста, подождите...';
            statusMessage.classList.remove('text-red-500', 'text-green-500');
            statusMessage.classList.add('text-gray-500');

            try {
                // Rule 2.2.b: Двуязычный запрос, отправляем массив [русский, английский]
                const payload = {
                    queries: [query_ru, query_en] 
                };
                
                appendToLog(`[REQUEST] Отправка запроса к API: ${API_URL}`);
                
                // Имитация вызова API
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();

                if (response.ok && data.status === 'success') {
                    // Rule 2.4.a: Получаем результаты
                    allResults = data.results || []; 
                    
                    appendToLog(`[RESPONSE] API вернуло ${allResults.length} результатов за ${data.execution_time_seconds} сек.`);

                    if (allResults.length === 0) {
                        statusMessage.textContent = 'По вашему запросу ничего не найдено.';
                        statusMessage.classList.remove('text-green-500', 'text-gray-500');
                        statusMessage.classList.add('text-red-500');
                        filterBlock.classList.add('hidden');
                    } else {
                        // Сортировка по возрастанию цены уже должна быть выполнена на бэкенде (Rule 2.4.b)
                        // Применяем фильтры (изначально без изменений) и отображаем первую страницу
                        applyFiltersAndSort(); 
                        
                        statusMessage.textContent = `Найдено ${allResults.length} результатов. Отсортировано по цене.`;
                        statusMessage.classList.remove('text-red-500', 'text-gray-500');
                        statusMessage.classList.add('text-green-500');
                    }

                } else {
                    const errorMessage = data.message || 'Неизвестная ошибка API.';
                    appendToLog(`[ERROR] Ошибка API: ${errorMessage}`);
                    statusMessage.textContent = `Ошибка поиска: ${errorMessage}`;
                    statusMessage.classList.remove('text-green-500', 'text-gray-500');
                    statusMessage.classList.add('text-red-500');
                }

            } catch (error) {
                appendToLog(`[ERROR] Критическая ошибка сети/JSON: ${error.message}`);
                statusMessage.textContent = 'Критическая ошибка: Не удалось подключиться к серверу API.';
                statusMessage.classList.remove('text-green-500', 'text-gray-500');
                statusMessage.classList.add('text-red-500');
            } finally {
                searchButton.disabled = false;
            }
        }

        // --- Инициализация и Обработчики Событий ---

        // Обработчик формы поиска (Rule 2.1.a)
        searchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const query = searchInput.value.trim();
            if (query) {
                // Rule 2.1.a: захватываем запрос
                fetchSearchResults(query);
            }
        });

        // Обработка пагинации
        prevPageButton.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                renderPage();
            }
        });

        nextPageButton.addEventListener('click', () => {
            const totalPages = Math.ceil(filteredResults.length / ITEMS_PER_PAGE);
            if (currentPage < totalPages) {
                currentPage++;
                renderPage();
            }
        });
        
        // Обработка фильтрации (Rule 2.4.c)
        applyFiltersButton.addEventListener('click', applyFiltersAndSort);
        // Также можно применить фильтры при нажатии Enter в полях
        priceFilterMin.addEventListener('keypress', (e) => { if (e.key === 'Enter') applyFiltersAndSort(); });
        priceFilterMax.addEventListener('keypress', (e) => { if (e.key === 'Enter') applyFiltersAndSort(); });
        
        // Инициализация при загрузке страницы
        window.onload = () => {
            statusMessage.textContent = 'Введите запрос для начала поиска.';
        }

    </script>
</body>
</html>

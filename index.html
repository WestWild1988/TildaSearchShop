<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSP Оборудование: Поиск по Интернет-Источникам</title>
    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Настройки шрифта и основного контейнера */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        :root {
            --dark-bg: #030712; /* Базовый темный фон */
            --card-bg: #111827; /* Фон карточек, как в правилах (Rule 4.3) */
            --accent-color: #4f46e5; /* Индиго для акцентов */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            color: #f3f4f6;
        }

        /* Стиль для карточки результата с анимацией (Rule 4.3) */
        .equipment-card {
            background-color: var(--card-bg);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .equipment-card:hover {
            transform: translateY(-5px); /* Анимация поднятия */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Усиленная тень */
        }

        /* Стиль для инпутов, чтобы они выглядели хорошо на темном фоне */
        input[type="text"], input[type="number"] {
            background-color: #1f2937; /* Немного светлее, чем фон карточки */
            border-color: #374151;
            color: #f3f4f6;
        }

        input[type="text"]::placeholder, input[type="number"]::placeholder {
            color: #9ca3af;
        }
    </style>
</head>
<body class="min-h-screen">
    
    <div class="container mx-auto p-4 md:p-8">

        <!-- Заголовок -->
        <header class="text-center mb-10">
            <h1 class="text-4xl font-extrabold text-gray-100">PSP Агрегатор Поиска Оборудования</h1>
            <p class="text-gray-400 mt-2">Единый поиск по интернет-источникам РФ и СНГ</p>
        </header>

        <!-- Поисковая Форма -->
        <div class="max-w-4xl mx-auto bg-gray-800 p-6 rounded-xl shadow-2xl mb-8">
            <form id="search-form" class="flex flex-col sm:flex-row gap-4 mb-4">
                <input type="text" id="search-input" placeholder="Введите название оборудования (напр., Shure SM58)" required 
                       class="flex-grow p-3 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-150">
                <button type="submit" id="search-button" 
                        class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out disabled:bg-indigo-400 disabled:cursor-not-allowed">
                    Найти
                </button>
            </form>

            <!-- Фильтры и Сортировка -->
            <div id="filters-container" class="mt-4 p-4 border border-gray-700 rounded-xl bg-gray-900 shadow-inner">
                <h3 class="text-lg font-semibold mb-3 text-indigo-300">Фильтрация по Цене (₽)</h3>
                <div class="flex flex-col sm:flex-row gap-4 items-end">
                    <div class="flex-1 w-full sm:w-auto">
                        <label for="price-min" class="block text-sm font-medium text-gray-400">Мин. Цена</label>
                        <input type="number" id="price-min" placeholder="0" min="0" 
                               class="w-full p-2 rounded-lg border focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div class="flex-1 w-full sm:w-auto">
                        <label for="price-max" class="block text-sm font-medium text-gray-400">Макс. Цена</label>
                        <input type="number" id="price-max" placeholder="50000" min="0" 
                               class="w-full p-2 rounded-lg border focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <button id="apply-filters-button" 
                            class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out flex-shrink-0">
                        Применить
                    </button>
                </div>
            </div>
        </div>

        <!-- Сообщение о статусе -->
        <p id="status-message" class="text-center text-gray-500 text-lg mb-6"></p>

        <!-- Контейнер Результатов Поиска -->
        <div id="results-container" class="grid grid-cols-1 gap-6 mb-8">
            <!-- Сюда будут вставляться карточки результатов -->
        </div>

        <!-- Пагинация -->
        <div id="pagination-container" class="max-w-4xl mx-auto flex justify-center items-center space-x-4 mb-10 hidden">
            <button id="prev-page-button" disabled 
                    class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg disabled:opacity-50 transition duration-150">
                Предыдущая
            </button>
            <span id="page-info" class="text-gray-300 font-medium">Страница 1 из 4</span>
            <button id="next-page-button" disabled 
                    class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg disabled:opacity-50 transition duration-150">
                Следующая
            </button>
        </div>

        <!-- Лог Запросов (для отладки) -->
        <div class="max-w-4xl mx-auto mt-8 p-4 bg-gray-900 rounded-xl shadow-lg border border-gray-700">
            <h3 class="text-xl font-bold text-gray-300 mb-2">Лог Событий (Frontend)</h3>
            <div id="log-container" class="text-sm space-y-1 h-32 overflow-y-auto text-gray-400">
                <!-- Сюда добавляются сообщения лога -->
            </div>
        </div>

    </div>

    <script>
        // --- КОНСТАНТЫ И ПЕРЕМЕННЫЕ ---
        const API_ENDPOINT = '/search_api'; 
        const ITEMS_PER_PAGE = 5; // Rule 2.4.d: 5 элементов на страницу
        
        let allResults = [];      // Все 20 результатов с API
        let filteredResults = []; // Результаты после фильтрации/сортировки
        let currentPage = 1;      
        
        // --- ЭЛЕМЕНТЫ DOM ---
        const searchForm = document.getElementById('search-form');
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const resultsContainer = document.getElementById('results-container');
        const statusMessage = document.getElementById('status-message');
        const logContainer = document.getElementById('log-container');
        const prevPageButton = document.getElementById('prev-page-button');
        const nextPageButton = document.getElementById('next-page-button');
        const pageInfo = document.getElementById('page-info');
        const applyFiltersButton = document.getElementById('apply-filters-button');
        const priceFilterMin = document.getElementById('price-min');
        const priceFilterMax = document.getElementById('price-max');
        const paginationContainer = document.getElementById('pagination-container');


        // --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---

        /**
         * Добавляет сообщение в Лог Событий.
         * @param {string} message 
         */
        function appendToLog(message) {
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('p');
            logEntry.textContent = `[${time}] ${message}`;
            logContainer.prepend(logEntry); // Добавляем сверху
        }
        
        /**
         * Форматирует число в валютный формат (₽).
         * @param {number} price 
         * @returns {string} Отформатированная строка цены.
         */
        function formatPrice(price) {
            return new Intl.NumberFormat('ru-RU', {
                style: 'currency',
                currency: 'RUB',
                minimumFractionDigits: 0
            }).format(price);
        }

        /**
         * Рендерит одну карточку результата.
         * @param {object} item Объект результата поиска.
         */
        function createResultCard(item) {
            const isBestOffer = item.rank === 1; // Rule 4.4

            const card = document.createElement('div');
            card.className = `equipment-card p-6 rounded-xl shadow-lg transition duration-300 border ${isBestOffer ? 'border-amber-400 ring-4 ring-amber-400/50' : 'border-gray-700'}`;
            
            // HTML для карточки
            card.innerHTML = `
                <div class="flex items-start justify-between mb-3">
                    <h2 class="text-xl font-bold text-indigo-300">
                        <a href="${item.uri}" target="_blank" class="hover:underline transition duration-150">${item.title}</a>
                    </h2>
                    ${isBestOffer ? `
                        <span class="ml-4 flex-shrink-0 bg-amber-500 text-gray-900 text-xs font-extrabold px-3 py-1 rounded-full shadow-lg">
                            ЛУЧШАЯ ЦЕНА
                        </span>
                    ` : ''}
                </div>
                <p class="text-3xl font-extrabold text-white mb-4">${formatPrice(item.price)}</p>
                <p class="text-gray-300 mb-4 text-sm">${item.snippet || 'Краткое описание отсутствует.'}</p>
                
                <div class="flex flex-wrap gap-x-4 gap-y-2 text-sm text-gray-400">
                    <div class="flex items-center space-x-1">
                        <!-- Иконка источника (простой SVG) -->
                        <svg class="w-4 h-4 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg>
                        <span>Источник: <span class="font-medium text-gray-200">${item.source}</span></span>
                    </div>
                    <div class="flex items-center space-x-1">
                        <!-- Иконка ссылки (простой SVG) -->
                        <svg class="w-4 h-4 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 10-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.818l5.656-5.656-1.102-1.101m-4.818.758a4 4 0 105.656 0l-4-4a4 4 0 10-5.656-5.656l-1.102 1.101"></path></svg>
                        <span>Ссылка: <a href="${item.uri}" target="_blank" class="text-indigo-400 hover:text-indigo-300 truncate max-w-[150px] inline-block sm:max-w-full">${new URL(item.uri).hostname}</a></span>
                    </div>
                </div>
            `;
            return card;
        }

        /**
         * Рендерит текущую страницу результатов.
         */
        function renderPage() {
            resultsContainer.innerHTML = '';
            
            const totalItems = filteredResults.length;
            const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
            
            const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
            const endIndex = Math.min(startIndex + ITEMS_PER_PAGE, totalItems);

            const resultsToRender = filteredResults.slice(startIndex, endIndex);

            if (resultsToRender.length === 0 && totalItems > 0) {
                 // Если на текущей странице нет результатов, но они есть всего,
                 // переходим на последнюю доступную страницу
                 currentPage = totalPages;
                 renderPage();
                 return;
            }

            resultsToRender.forEach(item => {
                resultsContainer.appendChild(createResultCard(item));
            });

            // Обновление пагинации
            prevPageButton.disabled = currentPage === 1;
            nextPageButton.disabled = currentPage === totalPages || totalPages === 0;
            pageInfo.textContent = `Страница ${totalPages > 0 ? currentPage : 0} из ${totalPages}`;
            
            if (totalItems > 0) {
                paginationContainer.classList.remove('hidden');
                statusMessage.textContent = `Найдено ${totalItems} предложений. Отображаются с ${startIndex + 1} по ${endIndex}.`;
                statusMessage.classList.remove('text-indigo-400', 'text-red-500');
                statusMessage.classList.add('text-green-500');
            } else if (allResults.length > 0) {
                paginationContainer.classList.add('hidden');
                statusMessage.textContent = 'Результаты не найдены в соответствии с заданными фильтрами.';
                statusMessage.classList.remove('text-indigo-400', 'text-green-500');
                statusMessage.classList.add('text-red-500');
            }
        }

        /**
         * Применяет фильтры по цене и сортирует результаты по цене (Rule 2.4.b, 2.4.c).
         */
        function applyFiltersAndSort() {
            const minPrice = parseFloat(priceFilterMin.value) || 0;
            const maxPrice = parseFloat(priceFilterMax.value) || Infinity;

            filteredResults = allResults.filter(item => 
                item.price >= minPrice && item.price <= maxPrice
            );

            // Сортировка по возрастанию цены (Rule 2.4.b)
            filteredResults.sort((a, b) => a.price - b.price);
            
            // Устанавливаем ранг 1 для самого дешевого в отфильтрованном списке
            filteredResults.forEach(item => item.rank = 0);
            if (filteredResults.length > 0) {
                filteredResults[0].rank = 1;
            }

            currentPage = 1;
            appendToLog(`[FILTERS] Фильтры применены. Мин: ${minPrice}, Макс: ${maxPrice}. Найдено: ${filteredResults.length} после фильтрации.`);
            renderPage();
        }

        /**
         * Использует Gemini API для перевода русского запроса на английский (Rule 2.1.c).
         * @param {string} queryRu Русский запрос.
         * @returns {Promise<string>} Английский перевод или оригинальный запрос в случае ошибки.
         */
        async function translateQuery(queryRu) {
            const systemPrompt = "Ты — профессиональный переводчик. Твоя единственная задача — перевести предоставленный запрос оборудования с русского на английский язык. Отвечай только переведенным текстом, без лишних слов, пояснений и пунктуации.";
            const userQuery = `Переведи на английский: ${queryRu}`;
            
            // NOTE: Using the standard API URL and model for text generation
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            appendToLog(`[GEMINI] Запрос на перевод: "${queryRu}"...`);
            
            // Retry mechanism for API calls
            const maxRetries = 3;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

                    if (text) {
                        appendToLog(`[GEMINI] Перевод успешен: "${text}"`);
                        // Очищаем от возможных кавычек, которые может добавить модель
                        return text.replace(/^"|"$/g, '').trim(); 
                    } else {
                        throw new Error("Translation content missing or empty in response.");
                    }

                } catch (error) {
                    appendToLog(`[ERROR] Попытка ${attempt + 1} перевода не удалась: ${error.message}`);
                    if (attempt === maxRetries - 1) {
                        // На финальной ошибке возвращаем оригинальный запрос
                        appendToLog(`[FALLBACK] Не удалось перевести. Используется оригинальный запрос.`);
                        return queryRu;
                    }
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000)); // Экспоненциальная задержка
                }
            }
        }

        /**
         * Выполняет POST-запрос к API для поиска результатов.
         * @param {string[]} queries Массив запросов [queryRu, queryEn]. (Rule 2.2.a)
         */
        async function fetchSearchResults(queries) {
            
            appendToLog(`[NETWORK] Вызов API: ${API_ENDPOINT}`);
            
            const payload = {
                queries: queries
            };

            const maxRetries = 3;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        // 2.4.a: Фронтенд получает результаты
                        allResults = data.results || []; 
                        appendToLog(`[SUCCESS] API вернуло ${allResults.length} результатов за ${data.execution_time_seconds} сек.`);
                        
                        // Применяем фильтрацию и сортировку (Rule 2.4.b, 2.4.c)
                        applyFiltersAndSort();
                        
                        // Показываем пагинацию, если есть результаты
                        if (allResults.length > 0) {
                            paginationContainer.classList.remove('hidden');
                        } else {
                            paginationContainer.classList.add('hidden');
                            statusMessage.textContent = 'Поиск завершен. Результаты не найдены.';
                            statusMessage.classList.remove('text-green-500', 'text-indigo-400');
                            statusMessage.classList.add('text-red-500');
                        }
                        
                        return; // Успех, выходим из цикла
                    } else {
                        // Обработка ошибки со стороны API
                        const errorMessage = data.message || data.error || 'Неизвестная ошибка API.';
                        appendToLog(`[API ERROR] Попытка ${attempt + 1}: ${errorMessage}`);
                        statusMessage.textContent = `Ошибка API: ${errorMessage}`;
                        statusMessage.classList.remove('text-green-500', 'text-indigo-400');
                        statusMessage.classList.add('text-red-500');
                    }

                } catch (error) {
                    appendToLog(`[NETWORK ERROR] Попытка ${attempt + 1} не удалась: ${error.message}`);
                    if (attempt === maxRetries - 1) {
                         // Критическая ошибка сети/JSON
                        statusMessage.textContent = 'Критическая ошибка: Не удалось подключиться к серверу API.';
                        statusMessage.classList.remove('text-green-500', 'text-indigo-400');
                        statusMessage.classList.add('text-red-500');
                    }
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000)); // Экспоненциальная задержка
                }
            }
        }

        // --- ИНИЦИАЛИЗАЦИЯ И ОБРАБОТЧИКИ СОБЫТИЙ ---

        searchForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const queryRu = searchInput.value.trim();
            if (!queryRu) return;

            // 2.1.b: Очистка предыдущих результатов и логов
            resultsContainer.innerHTML = '';
            // Лог не очищаем, чтобы видеть историю
            statusMessage.textContent = 'Выполняется поиск...';
            statusMessage.classList.remove('text-red-500', 'text-green-500');
            statusMessage.classList.add('text-indigo-400');
            searchButton.disabled = true;

            try {
                // 2.1.c: Выполнение перевода (если запрос на русском)
                const queryEn = await translateQuery(queryRu);
                
                // 2.2.b: Формирование двуязычного запроса
                const queries = (queryRu === queryEn) ? [queryRu] : [queryRu, queryEn];
                appendToLog(`[FRONTEND] Отправка запросов к API: ${queries.join('; ')}`);

                // 2.2.a: Вызов основной функции поиска
                await fetchSearchResults(queries);

            } catch (error) {
                // Ошибка обработки или перевода
                appendToLog(`[ERROR] Ошибка при инициации поиска/перевода: ${error.message}`);
                statusMessage.textContent = 'Критическая ошибка при инициации поиска.';
                statusMessage.classList.remove('text-indigo-400');
                statusMessage.classList.add('text-red-500');
            } finally {
                searchButton.disabled = false;
            }
        });

        // Обработка пагинации
        prevPageButton.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                appendToLog(`[PAGINATION] Переход на страницу ${currentPage}`);
                renderPage();
                // Прокрутка к началу результатов
                resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });

        nextPageButton.addEventListener('click', () => {
            const totalPages = Math.ceil(filteredResults.length / ITEMS_PER_PAGE);
            if (currentPage < totalPages) {
                currentPage++;
                appendToLog(`[PAGINATION] Переход на страницу ${currentPage}`);
                renderPage();
                // Прокрутка к началу результатов
                resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });
        
        // Обработка фильтрации
        applyFiltersButton.addEventListener('click', applyFiltersAndSort);
        // Также можно применить фильтры при нажатии Enter в полях
        priceFilterMin.addEventListener('keypress', (e) => { if (e.key === 'Enter') applyFiltersAndSort(); });
        priceFilterMax.addEventListener('keypress', (e) => { if (e.key === 'Enter') applyFiltersAndSort(); });
        
        // Инициализация при загрузке страницы
        window.onload = () => {
            statusMessage.textContent = 'Введите запрос для начала поиска.';
            appendToLog('[INIT] Приложение PSP Агрегатор запущено.');
        }

    </script>

</body>
</html>
